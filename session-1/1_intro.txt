
Ã‰ste es un claro ejemplo de que si no tenemos un test que nos asegure que pasa en casos invÃ¡lidos podemos encontrarnos con graves problemas en producciÃ³n, mÃ¡s aÃºn si estamos trabajando con un lenguaje que no estÃ© fuertemente tipado como ocurre con Javascript


Testing

Los tests nos permiten automatizar conjuntos de pruebas sobre nuestro cÃ³digo que nos aseguren que se comportarÃ¡ como nosotros esperamos tanto en flujos vÃ¡lidos como invÃ¡lidos. Estas pruebas podremos realizarlas tanto a casos de uso concretos para ver que la lÃ³gica interna se ejecuta correctamente (Unit Test) como a los puntos de entrada tal y como lo harÃ­a un cliente para verificar que se recibe la respuesta esperada sin reparar en lo que suceda internamente (Acceptance test)


Por supuesto el hecho de preparar toda nuestra suite de tests sÃ³lo tiene sentido si estos se ejecutan y en este sentido cobra gran importancia las pipelines en herramientas de IntegraciÃ³n Continua (Jenkins, Travis, GitlabCI, Github Actionsâ€¦), es decir, pasos que van a ejecutarse antes de desplegar nuestro cÃ³digo. AÃ±adir nuestra suite de tests a esta pipeline nos permitirÃ­a asegurarnos de que el cÃ³digo que vamos a desplegar va a funcionar correctamente


Â¿Por quÃ©?

âœ… Evidencia empÃ­rica de que el software funciona como esperamos
ğŸ‘·â€â™€ï¸ Reproducir fÃ¡cilmente casos complejos
ğŸ› Evitar bugs (EconomÃ­a del software)
ğŸ™ Refactorizar y aÃ±adir funcionalidades en paz
ğŸš€ AutomatizaciÃ³n (habilita CI)
Explorar funcionalidades

